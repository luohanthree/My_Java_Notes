# 并发

## 线程

### 线程的状态

- New(新建)
- Runnable(可运行)
- Blocked(阻塞)
- Waiting(等待)
- Timed waiting(计时等待)
- Terminated(终止)

---

### 新建线程

#### 可运行线程

一旦调用start方法，线程就处于可运行的状态。一个可运行的线程可能正在运行也可能没有运行。

在桌面和服务器设备中，一个线程只有在调用 *yield* 方法或被阻塞或等待时才会失去控制权

#### 阻塞或等待线程

当线程处于等待或阻塞状态时，他暂时是不活动的。

- 当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有，该线程就会被阻塞。当其他 **所有** 线程都释放了这个锁，并且调度器允许该线程持有这个锁时，他将变成非阻塞

- 当线程等待另一个线程通知调度器出现一个条件时，这个线程进入等待状态

- 当有几个方法有超时参数，调用这些方法会让线程进入计时等待

<img title="" src="file:///home/zhihuanzhihuan/图片/bluetooth/weread_image_288904083766331.jpeg" alt="" width="356">

#### 终止线程

线程或因为以下两个原因而终止：

- run方法异常退出，线程自然中终止

- 因为没有正常捕获的异常终止了run方法，使线程意外终止

---

```java
void join() //等待终止指定线程
void join(long mills) //等待指定的线程或等待经过指定的毫秒数
Thread.State getState() //得到这个线程的状态；
```

## 线程属性

#### 中断线程

当线程的 *run* 方法执行方法体中最后一条语句后在执行 *return* 退出，或出现了方法中没有捕获的异常时，线程将终止。

可以使用 *interrupt* 方法来 ***请求*** 终止一个线程。

当一个线程调用 *interrupt* 方法时，就会设置线程的 ***中断状态*** 。每个线程都有的boolean标志。每个线程都应检查这个标志，判断线程是否中断。

要想得出线程是否设置了中断状态，首先调用静态的 *Thread.currentThread* 方法获得当前线程，然后调用 *isInterrupted* 方法

```java
while(!Thread.currentThread().isInterrupted() && ... ) {
    ...
}
```

但是如果线程被 ***阻塞***，就 ***无法检查*** 中断状态。这里引入 ***InterruptedException*** 异常。当在一个被 ***sleep*** 或 ***wait*** 调用阻塞的线程上调用 ***interrupt*** 方法时，那个阻塞调用将被 ***InterrutedException*** 异常中断。

```java
Runnable r = () -> {
    try {
        ...
        while (!Thread.currentThread().isInterrupted() && ...){
        ...
        }
    } catch (InterruptedException e) {
        ... //thread was interrupted during sleep or wait
    }
    finally {
        ... //cleanup,if required
    }
    //exiting the run method terminates thread 
};
```

如果每次迭代之后都调用 ***sleep*** 方法(或其他的中断方法)，***isInterrupted*** 方法检查既没有必要也没有用处。如果设置了中断状态，此时倘若调用 ***sleep*** 方法，他**不会**休眠。实际上，他会清除中断状态，并抛出 **InterruptedException**。

所以，如果循环调用了 ***sleep*** ,就不要检测中断状态，而应当捕获 ***InterrutedException*** 异常

```java
Runnable r = () -> {
    try {
    ...
    while(...) {
        ...
        Thread.sleep(delay);
        }
    }catch(InerruptedException e) {
    ...//Thread was interruted during sleep
    } finally {
        //cleaning up, if required
    }
};
```
